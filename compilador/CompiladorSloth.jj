PARSER_BEGIN(CompiladorSloth)
import java.util.ArrayList;
import java.util.List;

public class CompiladorSloth
{
    private static Codigo cod = new Codigo();
    
	public static void main(String[] args) throws ParseException
	{
		try
		{
			CompiladorSloth analizador = new CompiladorSloth(System.in) ;
			analizador.Programa();
		}
		catch(ParseException e)
		{
			System.out.println(e.getMessage());
			System.out.println("Analizador: foram encontrados alguns erros na analise.");
		}
		finally{
			System.out.println("\n--- Tokens Encontrados ---\n");
			for(Token nome : cod.getTokenList()){
            	System.out.println(
					"Token: " + tokenImage[nome.kind] + " -> " + nome.toString());
        	}
		}
	}
}

class Codigo
{
    private List<Token> tokenList = new ArrayList<Token>();

	public void add(Token t){
		tokenList.add(t);
	}

	public List<Token> getTokenList(){
		return tokenList;
	}
}
PARSER_END(CompiladorSloth)

SKIP:
{ 
	" "|"\n"|"\r"|"\r\n" 
}


TOKEN:
{
	<#LETRA: (["a"-"z","A"-"Z"])>
	|<#DIGITO: (["0" - "9"])>
	|<#CARACTERE: (<LETRA>|<DIGITO>)>
	|<#ASC: (["\0"-"!","$"-"&","("-"~"])> //tabela asc sem " ' #
}

TOKEN:
{
	<TIPOINT: "int">
	|<TIPODOUBLE: "double">
	|<TIPOCHAR: "char">
	|<TIPOSTRING: "string">
	|<TIPOBOOLEAN: "boolean">
}

TOKEN:
{
	<TRUE: "true">
	|<FALSE: "false">
}

TOKEN:
{
	<ENDL: "\\n">
	|<EOL: ";">
}

TOKEN:
{
	<ABREVET: "[">
	|<FECHAVET: "]">
}

TOKEN:
{
	<ADD: "+">
	|<SUB: "-">
	|<MULT: "*">
	|<MOD: "//">
	|<DIV: "/">
	|<POW: "^">
	|<PORCE: "%">
	|<ABREPAR: "(">
	|<FECHAPAR: ")">
	|<PONTO: ".">
}

TOKEN:
{
	<IGUAL: "==">
	|<DIF: "=!">
	|<MAIOR: ">">
	|<MENOR: "<">
	|<MAIGUAL: "=>">
	|<MEIGUAL: "=<">
	|<IGUALDADE: "=">
}

TOKEN:
{
	<AND: "&&">
	|<OR: "||">
	|<NOT: "!">
	|<XOR: "|+">
}

TOKEN:
{
	<IF: "when">
	|<ELSE: "otherwise">
}

TOKEN:
{	
	<FOR: "for">
	|<SEPFOR: ":">
	|<WHILE: "while">
	|<FOREACH: "foreach">
}

TOKEN:
{
	<FIRST: "first">
	|<LAST: "last">
	|<BEGIN: "begin">
	|<END: "end">
}

TOKEN:
{
	<IMPORT: "import">
	|<GET: "get">
	|<WRITE: "write">
	|<COMENT: "#"(<ASC>)*"#">
}

TOKEN:
{
	<STRING: "\""(<ASC>)*"\"">
	|<INTEIRO: (<DIGITO>)+>
	|<CARACTER: "'"<ASC>"'">
	|<REAL: <INTEIRO><PONTO><INTEIRO>>
	|<PORCENTAGEM: (<REAL>|<INTEIRO>)<PORCE>>
}

TOKEN:
{
	<NOMEVAR: <LETRA>(<CARACTERE>)*>
}

void Programa():
{} // (((Importacao()|<COMENT>)*Execucao())|Execucao())(<COMENT>)*<EOF>
   // deixe por ultimo, use para ir testeando de um em um
{
	(Read())*<EOF>
}

void Importacao():
{Token a,b;} //<IMPORT><STRING>
{
	(a=<IMPORT>){cod.add(a);}
	(b=<STRING>){cod.add(b);}
}

void Execucao():
{Token a,b;} //<FIRST>(Linha())*<LAST>
{
	(a=<FIRST>){cod.add(a);}
	(Linha())*
	(b=<LAST>){cod.add(b);}
}

void Linha():
{} //((Write()|ManVar())<EOL>)|FluxoDados()
{
	<INTEIRO>
}

void Write():
{} //<WRITE><ABREPAR>Expressao()<FECHAPAR>
{
	<INTEIRO>
}

void ManVar():
{} //(TipoVar()NomeVar()[Atribuicao()])|(NomeVar()Atribuicao())
   // [algo] significa que pode ter ou nao
{
	<INTEIRO>
}

void TipoVar():
{Token a=null;} // <TIPOBOOLEAN>|<TIPOCHAR>|<TIPODOUBLE>|<TIPOINT>|<TIPOSTRING>
{
	(a=<TIPOBOOLEAN>|a=<TIPOCHAR>|a=<TIPODOUBLE>|a=<TIPOINT>|a=<TIPOSTRING>)
	{cod.add(a);}
}

void NomeVar():
{} // <NOMEVAR>[<ABREVET>Expressao()<FECHAVET>]
{
	<INTEIRO>
}

void Atribuicao():
{} // <IGUALDADE>(Read()|Expressao())
{
	<INTEIRO>
}

void Read():
{Token a,b,c;} // <GET><ABREPAR><FECHAPAR>
{
	(a=<GET>) {cod.add(a);}
	(b=<ABREPAR>) {cod.add(b);}
	(c=<FECHAPAR>) {cod.add(c);}
}

void Expressao():
{} /*
((<ABREPAR>(Expressao())+<FECHAPAR>)
| <NOT>Expressao()
| NomeVar()
| ValorVar())
[LOOKAHEAD(2) Operador()Expressao()]

LOOKAHEAD serve para nao dar warning,
porque ele pode ou nao terminar em Operador()Expressao()
podendo entrar em conflito com outro automato que comece em Operador(),
*/
{
	<INTEIRO>
}

void Operador():
{} // OpArit()|OpRelac()
{
	<INTEIRO>
}

void OpArit():
{} // <ADD>|<SUB>|<MOD>|<DIV>|<POW>|<MULT>
   // Talvez ele de um warning com o <DIV> e <MULT>
{
	<INTEIRO>
}

void OpRelac():
{} // <AND>|<OR>|<XOR>|<IGUAL>|<DIF>|<MAIGUAL>|<MEIGUAL>|<MAIOR>|<MENOR>
   // Talvez ele de um warning com o <MAIGUAL> e <MAIOR> e do menor
{
	<INTEIRO>
}

void ValorVar():
{} // <INTEIRO>|<REAL>|<CARACTER>|Booleano()|<PORCENTAGEM>|<STRING>
   // nao confundir <CARACTER> com <CARACTERE> haha
{
	<INTEIRO>
}

void Booleano():
{} // <TRUE>|<FALSE>
{
	<INTEIRO>
}

void FluxoDados():
{} // While()|For()|Foreach()|If()
{
	<INTEIRO>
}

void While():
{} // <WHILE><ABREPAR>Expressao()<FECHAPAR>Bloco()
{
	<INTEIRO>
}

void For():
{}/*
<FOR><ABREPAR>NomeVar()<IGUALDADE>
(ValorVar()|NomeVar())<SEPFOR>
(ValorVar()|NomeVar())<SEPFOR>
(ValorVar()|NomeVar())<FECHAPAR>Bloco()
*/
{
	<INTEIRO>
}

void Foreach():
{} // <FOREACH><ABREPAR>NomeVar()<SEPFOR>NomeVar()<FECHAPAR>Bloco()
{
	<INTEIRO>
}

void If():
{} // <IF><ABREPAR>Expressao()<FECHAPAR>Bloco()[<ELSE>Bloco()]
{
	<INTEIRO>
}

void Bloco():
{} //<BEGIN>(Linha()|<COMENT>)<END>
{
	<INTEIRO>
}